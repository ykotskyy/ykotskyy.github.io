<!DOCTYPE html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script src="https://d3js.org/d3.v6.min.js"></script>
  <title> Stock Chart in D3 </title>
</head>

<body>
  <div id="chart"></div>
</body>


<style>
body {
  background: #00151c;
}

#chart {
  background: #0e3040;
  color: #67809f;
}

</style>


<script>
// All the JavaScript is here
const loadDataEndOfDay = d3.csv("data/aal_test.csv", d => ({
  date: new Date(d.Date),
  volume: Number(d.volume),
  high: Number(d.High),
  low: Number(d.Low),
  open: Number(d.Open),
  close: Number(d.Close),
//adjclose: Number(d.),
  symbol: (d.Name)

}));

loadDataEndOfDay.then(data => {
  // render the chart here
  initialiseChart(data);
});

const initialiseChart = data => {
  const margin = { top: 50, right: 50, bottom: 50, left: 50 };
  const width = window.innerWidth - margin.left - margin.right; // Use the window's width
  const height = window.innerHeight - margin.top - margin.bottom; // Use the window's height

  // add chart SVG to the page
  const svg = d3
    .select('#chart')
    .append('svg')
    .attr('width', width + margin['left'] + margin['right'])
    .attr('height', height + margin['top'] + margin['bottom'])
    .append('g')
    .attr('transform', `translate(${margin['left']}, ${margin['top']})`);


  // find data range
  const xMin = d3.min(data, d => {
    return d['date'];
  });

  const xMax = d3.max(data, d => {
    return d['date'];
  });

  const yMin = d3.min(data, d => {
    return d['close'];
  });

  const yMax = d3.max(data, d => {
    return d['close'];
  });

  // scale using range
  const xScale = d3
    .scaleTime()
    .domain([xMin, xMax])
    .range([0, width]);

  const yScale = d3
    .scaleLinear()
    .domain([yMin - 5, yMax])
    .range([height, 0]);


  // create the axes component
  svg
    .append('g')
    .attr('id', 'xAxis')
    .attr('transform', `translate(0, ${height})`)
    .call(d3.axisBottom(xScale));

  svg
    .append('g')
    .attr('id', 'yAxis')
    .attr('transform', `translate(${width}, 0)`)
    .call(d3.axisRight(yScale));

    const line = d3
      .line()
      .x(d => {
        return xScale(d['date']);
      })
      .y(d => {
        return yScale(d['close']);
      });
    // Append the path and bind data
    svg
     .append('path')
     .data([data])
     .style('fill', 'none')
     .attr('id', 'priceChart')
     .attr('stroke', 'steelblue')
     .attr('stroke-width', '1.5')
     .attr('d', line);
     // renders x and y crosshair
     const focus = svg
       .append('g')
       .attr('class', 'focus')
       .style('display', 'none');
     focus.append('circle').attr('r', 4.5);
     focus.append('line').classed('x', true);
     focus.append('line').classed('y', true);
     svg
       .append('rect')
       .attr('class', 'overlay')
       .attr('width', width)
       .attr('height', height)
       .on('mouseover', () => focus.style('display', null))
       .on('mouseout', () => focus.style('display', 'none'))
       .on('mousemove', generateCrosshair);
     d3.select('.overlay').style('fill', 'none');
     d3.select('.overlay').style('pointer-events', 'all');
     d3.selectAll('.focus line').style('fill', 'none');
     d3.selectAll('.focus line').style('stroke', '#67809f');
     d3.selectAll('.focus line').style('stroke-width', '1.5px');
     d3.selectAll('.focus line').style('stroke-dasharray', '3 3');

     const bisectDate = d3.bisector(d => d.date).left;
     function generateCrosshair() {
       //returns corresponding value from the domain
       const correspondingDate = xScale.invert(d3.mouse(this)[0]);
       //gets insertion point
       const i = bisectDate(data, correspondingDate, 1);
       const d0 = data[i - 1];
       const d1 = data[i];
       const currentPoint = correspondingDate - d0['date'] > d1['date'] - correspondingDate ? d1 : d0;

       focus.attr('transform',`translate(${xScale(currentPoint['date'])},     ${yScale(currentPoint['close'])})`);
     focus
       .select('line.x')
       .attr('x1', 0)
       .attr('x2', width - xScale(currentPoint['date']))
       .attr('y1', 0)
       .attr('y2', 0);
     focus
       .select('line.y')
       .attr('x1', 0)
       .attr('x2', 0)
       .attr('y1', 0)
       .attr('y2', height - yScale(currentPoint['close']));
      updateLegends(currentPoint);
     }

}


 </script>
