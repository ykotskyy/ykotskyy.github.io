<!DOCTYPE html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script src="https://d3js.org/d3.v6.min.js"></script>
  <script src="graph.js"></script>
  <title> MoneyTalk </title>
</head>

<body>
  <div id="chart">
    <div id = "info">
      <p>

      </p>
    <script>
      // self executing function here
      (function() {
         // your page initialization code here
         // the DOM will be available here
         console.log("made it to graph data");
    // All the JavaScript is here
var extra =
d3.csv("data/test.csv", function(data){
return data;
});
console.log(extra);
 //d3.csv("data/test.csv").then(function(data) {

  //});

 d3.select("info")
                  .selectAll("p")
                  .data(extra)
                  .enter()
                  .append("p");
                //  .text(function(d){ return "This is data element #" + d; });

const loadDataEndOfDay = d3.csv("data/aal_test.csv", d => ({
  date: new Date(d.Date),
  volume: Number(d.Volume),
  high: Number(d.High),
  low: Number(d.Low),
  open: Number(d.Open),
  close: Number(d.Close),
  symbol: (d.Name),
  comment: String(d.Comments)

}));

loadDataEndOfDay.then(data => {
  // render the chart here
  initialiseChart(data);
});

const initialiseChart = data => {
  const margin = { top: 50, right: 50, bottom: 50, left: 50 };
  const width = window.innerWidth - margin.left - margin.right; // Use the window's width
  const height = window.innerHeight - margin.top - margin.bottom; // Use the window's height

  // add chart SVG to the page
  const svg = d3
    .select('#chart')
    .append('svg')
    .attr('width', width + margin['left'] + margin['right'])
    .attr('height', height + margin['top'] + margin['bottom'])
    .append('g')
    .attr('transform', `translate(${margin['left']}, ${margin['top']})`);


  // find data range
  const xMin = d3.min(data, d => {
    return d['date'];
  });

  const xMax = d3.max(data, d => {
    return d['date'];
  });

  const yMin = d3.min(data, d => {
    return d['close'];
  });

  const yMax = d3.max(data, d => {
    return d['close'];
  });

  // scale using range
  const xScale = d3
    .scaleTime()
    .domain([xMin, xMax])
    .range([0, width]);

  const yScale = d3
    .scaleLinear()
    .domain([yMin - 5, yMax])
    .range([height, 0]);

    svg
          .selectAll("dot")
           .data(data)
           .enter()
           .append("circle")
             .attr("r", 5)
             .attr("fill", function(d) {
               if(d.comment) {return "red"}
               else {return "transparent"};

             })
             .attr("stroke", "none")
             .attr("cx", function(d) { return xScale(d.date) })
             .attr("cy", function(d) { return yScale(d.close) })

  // create the axes component
  svg
    .append('g')
    .attr('id', 'xAxis')
    .attr('transform', `translate(0, ${height})`)
    .call(d3.axisBottom(xScale));

  svg
    .append('g')
    .attr('id', 'yAxis')
    .attr('transform', `translate(${width}, 0)`)
    .call(d3.axisRight(yScale));

    const line = d3
      .line()
      .x(d => {
        return xScale(d['date']);
      })
      .y(d => {
        return yScale(d['close']);
      });
    // Append the path and bind data
    svg
     .append('path')
     .data([data])
     .style('fill', 'none')
     .attr('id', 'priceChart')
     .attr('stroke', 'steelblue')
     .attr('stroke-width', '1.5')
     .attr('d', line)
     //.attr("data-legend",function(d1) { return d2.Name});

     // renders x and y crosshair
     const focus = svg
       .append('g')
       .attr('class', 'focus')
       .style('display', 'none');
     focus.append('circle').attr('r', 4.5);
     focus.append('line').classed('x', true);
     focus.append('line').classed('y', true);
     svg
       .append('rect')
       .attr('class', 'overlay')
       .attr('width', width)
       .attr('height', height)
       .on('mouseover', () => focus.style('display', null))
       .on('mouseout', () => focus.style('display', 'none'))
       .on('mousemove', generateCrosshair);
     d3.select('.overlay').style('fill', 'none');
     d3.select('.overlay').style('pointer-events', 'all');
     d3.selectAll('.focus line').style('fill', 'none');
     d3.selectAll('.focus line').style('stroke', '#67809f');
     d3.selectAll('.focus line').style('stroke-width', '1.5px');
     d3.selectAll('.focus line').style('stroke-dasharray', '3 3');

     const bisectDate = d3.bisector(d => d.date).left;
     function generateCrosshair() {
       //returns corresponding value from the domain
       const correspondingDate = xScale.invert(d3.pointer(event,this)[0]);
       //gets insertion point
       const i = bisectDate(data, correspondingDate, 1);
       const d0 = data[i - 1];
       const d1 = data[i];
       const currentPoint = correspondingDate - d0['date'] > d1['date'] - correspondingDate ? d1 : d0;

       focus.attr('transform',`translate(${xScale(currentPoint['date'])},     ${yScale(currentPoint['close'])})`);

     focus
       .select('line.x')
       .attr('x1', 0)
       .attr('x2', width - xScale(currentPoint['date']))
       .attr('y1', 0)
       .attr('y2', 0);
     focus
       .select('line.y')
       .attr('x1', 0)
       .attr('x2', 0)
       .attr('y1', 0)
       .attr('y2', height - yScale(currentPoint['close']));
      updateLegends(currentPoint);
    }



    const updateLegends = currentData => {
        d3.selectAll('.lineLegend').remove();
          const legendKeys = Object.keys(data[0]);
          const lineLegend = svg
            .selectAll('.lineLegend')
            .data(legendKeys)
            .enter()
            .append('g')
            .attr('class', 'lineLegend')
            .attr('transform', (d, i) => {
              return `translate(0, ${i * 20})`;
            });
          lineLegend
            .append('text')
            .text(d => {
              if (d === 'date') {
                return `${d}: ${currentData[d].toLocaleDateString()}`;
              } else if ( d === 'high' || d === 'low' || d === 'open' || d === 'close') {
                return `${d}: ${currentData[d].toFixed(2)}`;
              } else {
                return `${d}: ${currentData[d]}`;
              }
            })
            .style('fill', 'white')
            .attr('transform', 'translate(15,9)');
          };

          //legend = svg.append("g")
      //   .attr("class","legend")
      //   .attr("transform","translate(50,30)")
        // .style("font-size","12px")
      //   .call(d3.legend)

          /* Volume series bars */
            const volData = data.filter(d => d['volume'] !== null && d['volume'] !== 0);

            const yMinVolume = d3.min(volData, d => {
              return Math.min(d['volume']);
            });

            const yMaxVolume = d3.max(volData, d => {
              return Math.max(d['volume']);
            });

            const yVolumeScale = d3
              .scaleLinear()
              .domain([yMinVolume, yMaxVolume])
              .range([height, height * (3 / 4)]);

            svg
              .selectAll()
              .data(volData)
              .enter()
              .append('rect')
              .attr('x', d => {
                return xScale(d['date']);
              })
              .attr('y', d => {
                return yVolumeScale(d['volume']);
              })
              .attr('class', 'vol')
              .attr('fill', (d, i) => {
                if (i === 0) {
                  return '#03a678';
                } else {
                  return volData[i - 1].close > d.close ? '#c0392b' : '#03a678'; // green bar if price is rising during that period, and red when price  is falling
                }
              })
              .attr('width', 1)
              .attr('height', d => {
                return height - yVolumeScale(d['volume']);
              });

              const movingAverage = (data, numberOfPricePoints) => {
                return data.map((row, index, total) => {
                  const start = Math.max(0, index - numberOfPricePoints);
                  const end = index;
                  const subset = total.slice(start, end + 1);
                  const sum = subset.reduce((a, b) => {
                    return a + b['close'];
                  }, 0);

                  return {
                    date: row['date'],
                    average: sum / subset.length
                  };
                });
              };

  // calculates simple moving average over 50 days
  const movingAverageData = movingAverage(data, 49);
  // generates moving average curve when called
  const movingAverageLine = d3
   .line()
   .x(d => {
    return xScale(d['date']);
   })
   .y(d => {
    return yScale(d['average']);
   })
    .curve(d3.curveBasis);
  svg
    .append('path')
    .data([movingAverageData])
    .style('fill', 'none')
    .attr('id', 'movingAverageLine')
    .attr('stroke', '#FF8900')
    .attr('d', movingAverageLine);
};
      })();



      </script>
  </div>


</body>


<style>
body {
  background: #00151c;
}

#chart {
  background: #0e3040;
  color: #67809f;

}

#info{
  display:block;
  float:center;
  width:85%;
  height:50px;
  border:2px solid white;
  margin-left:10%;
  margin-bottom:10px;
  bottom:10px;
  background-color:white;

}
</style>


<script>
  // const bodyParser = require("body-parser");
// var mysql = require('mysql');

// const fs = require('fs');

// var con = mysql.createConnection({
//   host: "localhost",
//   user: "moneytalk_tliber2",
//  password: "Car42758663",
//   database: "moneytalk_test"
// });

// con.connect(function(err) {
//   if (err) throw err;
//   console.log("Connected to MySQL!");
// });

// async function getStockData(string) {

//   var sql = `SELECT * FROM teststock WHERE ticker = '${string}'`;
//   var toReturn;

//   //console.log("${dateIN}, ${highIN}, ${lowIN}, ${openIN}, ${closeIN}, ${volumeIN}, ${adjCloseIN}, ${tickerIN}");

//   console.log(sql);

//   con.query(sql, function (err, result) {
//     if (err) throw err;
//     //console.log(result.affectedRows + " record(s) updated");
//     console.log(result);
//     // await toReturn = result;
//   });

// const jsonData = JSON.parse(JSON.stringify(toReturn));
// console.log("jsonData", jsonData);




//    //  return toReturn;

//  below is to turn it into JSON, but i dont think we need to.

//   var inputArr = toReturn.split(",");

//   var dateIN = inputArr[0];
//   var highIN = inputArr[1];
//   var lowIN = inputArr[2];
//   var openIN = inputArr[3];
//   var closeIN = inputArr[4];
//   var volumeIN = inputArr[5];
//   var adjCloseIN = inputArr[6];
//   var tickerIN = inputArr[7];

//   var obj = JSON.parse("{ 'date':'${dateIN}', 'high': ${highIN}, 'low':${lowIN}, 'open':${openIN}, 'close':${closeIN}, 'volume':${volumeIN}, 'adjClose':${adjCloseIN}, 'ticker':${tickerIN}}'");

//   console.log(obj);

  //return obj;
// };


// var ticker = "";

// const loadDataEndOfDay = getStockData(ticker);


  function graphData(){



  }


 </script>
